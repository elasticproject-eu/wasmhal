// ELASTIC TEE HAL - Main World Definition
// WebAssembly Interface Types (WIT) for WASI 0.2 compliance

package elastic:tee-hal@0.1.0;

interface platform {
  record platform-info {
    platform-type: string,
    version: string,
    attestation-support: bool,
  }
  
  attestation: func() -> result<list<u8>, string>;
  platform-info: func() -> platform-info;
}

interface capabilities {
  record capability-info {
    feature-name: string,
    supported: bool,
    version: string,
  }
  
  list-capabilities: func() -> list<capability-info>;
  has-capability: func(feature-name: string) -> bool;
}

interface crypto {
  type crypto-context-handle = u64;
  
  enum hash-algorithm {
    sha256,
    sha512,
    blake3,
  }
  
  enum cipher-algorithm {
    aes256-gcm,
    chacha20-poly1305,
  }
  
  record key-pair {
    public-key: list<u8>,
    private-key: list<u8>,
  }
  
  hash: func(data: list<u8>, algorithm: hash-algorithm) -> result<list<u8>, string>;
  encrypt: func(data: list<u8>, key: list<u8>, algorithm: cipher-algorithm) -> result<list<u8>, string>;
  decrypt: func(data: list<u8>, key: list<u8>, algorithm: cipher-algorithm) -> result<list<u8>, string>;
  generate-keypair: func() -> result<key-pair, string>;
  sign: func(data: list<u8>, private-key: list<u8>) -> result<list<u8>, string>;
  verify: func(data: list<u8>, signature: list<u8>, public-key: list<u8>) -> result<bool, string>;
  create-context: func() -> result<crypto-context-handle, string>;
  destroy-context: func(handle: crypto-context-handle) -> result<unit, string>;
}

interface storage {
  type container-handle = u64;
  type object-handle = u64;
  
  record object-metadata {
    size: u64,
    created-at: u64,
    content-type: string,
  }
  
  create-container: func(name: string) -> result<container-handle, string>;
  open-container: func(name: string) -> result<container-handle, string>;
  delete-container: func(handle: container-handle) -> result<unit, string>;
  store-object: func(container: container-handle, key: string, data: list<u8>) -> result<object-handle, string>;
  retrieve-object: func(container: container-handle, key: string) -> result<list<u8>, string>;
  delete-object: func(container: container-handle, key: string) -> result<unit, string>;
  list-objects: func(container: container-handle) -> result<list<string>, string>;
  get-metadata: func(container: container-handle, key: string) -> result<object-metadata, string>;
}

interface sockets {
  type socket-handle = u64;
  
  enum protocol {
    tcp,
    udp,
    tls,
    dtls,
  }
  
  record address {
    ip: string,
    port: u16,
  }
  
  create-socket: func(protocol: protocol) -> result<socket-handle, string>;
  bind: func(socket: socket-handle, addr: address) -> result<unit, string>;
  listen: func(socket: socket-handle, backlog: u32) -> result<unit, string>;
  connect: func(socket: socket-handle, addr: address) -> result<unit, string>;
  accept: func(socket: socket-handle) -> result<socket-handle, string>;
  send: func(socket: socket-handle, data: list<u8>) -> result<u32, string>;
  receive: func(socket: socket-handle, max-len: u32) -> result<list<u8>, string>;
  close: func(socket: socket-handle) -> result<unit, string>;
}

interface gpu {
  type gpu-adapter-handle = u64;
  type gpu-device-handle = u64;
  type gpu-buffer-handle = u64;
  type gpu-pipeline-handle = u64;
  
  enum buffer-usage {
    storage,
    uniform,
    vertex,
    index,
  }
  
  record adapter-info {
    name: string,
    vendor: string,
    device-type: string,
  }
  
  record buffer-descriptor {
    size: u64,
    usage: buffer-usage,
  }
  
  list-adapters: func() -> result<list<gpu-adapter-handle>, string>;
  get-adapter-info: func(handle: gpu-adapter-handle) -> result<adapter-info, string>;
  create-device: func(adapter: gpu-adapter-handle) -> result<gpu-device-handle, string>;
  create-buffer: func(device: gpu-device-handle, descriptor: buffer-descriptor) -> result<gpu-buffer-handle, string>;
  write-buffer: func(buffer: gpu-buffer-handle, offset: u64, data: list<u8>) -> result<unit, string>;
  read-buffer: func(buffer: gpu-buffer-handle, offset: u64, size: u64) -> result<list<u8>, string>;
  create-compute-pipeline: func(device: gpu-device-handle, shader-code: list<u8>) -> result<gpu-pipeline-handle, string>;
  dispatch: func(device: gpu-device-handle, pipeline: gpu-pipeline-handle, x: u32, y: u32, z: u32) -> result<unit, string>;
}

interface resources {
  type allocation-id = string;
  
  enum resource-type {
    memory,
    cpu,
    storage,
    network,
  }
  
  record allocation-request {
    resource-type: resource-type,
    amount: u64,
    priority: u32,
  }
  
  record allocation-response {
    allocation-id: allocation-id,
    granted-amount: u64,
  }
  
  allocate: func(request: allocation-request) -> result<allocation-response, string>;
  deallocate: func(id: allocation-id) -> result<unit, string>;
  query-available: func(resource-type: resource-type) -> result<u64, string>;
}

interface events {
  type event-subscription-handle = u64;
  
  enum event-type {
    platform,
    crypto,
    storage,
    network,
    gpu,
  }
  
  record event-data {
    event-type: event-type,
    timestamp: u64,
    payload: list<u8>,
  }
  
  subscribe: func(event-type: event-type) -> result<event-subscription-handle, string>;
  unsubscribe: func(handle: event-subscription-handle) -> result<unit, string>;
  poll-events: func(handle: event-subscription-handle) -> result<list<event-data>, string>;
}

interface communication {
  type workload-id = string;
  type message-handle = u64;
  
  record message {
    sender: workload-id,
    recipient: workload-id,
    payload: list<u8>,
    encrypted: bool,
  }
  
  send-message: func(recipient: workload-id, data: list<u8>, encrypt: bool) -> result<message-handle, string>;
  receive-message: func() -> result<option<message>, string>;
  list-workloads: func() -> result<list<workload-id>, string>;
}

interface clock {
  record system-time {
    seconds: u64,
    nanoseconds: u32,
  }
  
  record monotonic-time {
    elapsed-seconds: u64,
    elapsed-nanoseconds: u32,
  }
  
  system-time: func() -> result<system-time, string>;
  monotonic-time: func() -> result<monotonic-time, string>;
  resolution: func() -> result<u64, string>;
  sleep: func(duration-ns: u64) -> result<unit, string>;
}

interface random {
  enum entropy-source {
    hardware,
    platform,
    userspace,
  }
  
  record entropy-info {
    source: entropy-source,
    quality: u32,
    available-bytes: u64,
  }
  
  get-random-bytes: func(length: u32) -> result<list<u8>, string>;
  get-secure-random: func(length: u32) -> result<list<u8>, string>;
  get-entropy-info: func() -> result<entropy-info, string>;
  reseed: func(additional-entropy: list<u8>) -> result<unit, string>;
}

world elastic-tee-hal {
  // Export all ELASTIC TEE HAL interfaces
  export platform;
  export capabilities;
  export crypto;
  export storage;
  export sockets;
  export gpu;
  export resources;
  export events;
  export communication;
  export clock;
  export random;
}
